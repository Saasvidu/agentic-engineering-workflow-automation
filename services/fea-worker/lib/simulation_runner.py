"""
Abaqus execution engine for FEA simulations.

This module runs inside the Abaqus container and executes simulation workflows
based on configuration files generated by the FEA worker.
"""

from abaqus import *
from abaqusConstants import *
import json


def run_cantilever_beam(config):
    """
    Execute a cantilever beam simulation based on configuration.
    
    Args:
        config: Configuration dictionary containing geometry, material, loading, and discretization
    """
    # Extract and sanitize model name for Abaqus compliance
    raw_name = config.get('MODEL_NAME', 'Not_Found')
    MODEL_NAME = "Job_" + str(raw_name).replace("-", "_")[:35]  # Abaqus 38-char limit
    
    # Extract parameters
    geom = config['GEOMETRY']
    PART_LENGTH = geom['length_m']
    PART_WIDTH = geom['width_m']
    PART_HEIGHT = geom['height_m']
    
    mat = config['MATERIAL']
    MAT_NAME = mat['name']
    YOUNGS_MODULUS = mat['youngs_modulus_pa']
    POISSON_RATIO = mat['poisson_ratio']
    
    load = config['LOADING']
    TIP_LOAD = load['tip_load_n']
    
    disc = config['DISCRETIZATION']
    N_ELEMENTS_LENGTH = disc['elements_length']
    N_ELEMENTS_WIDTH = disc['elements_width']
    N_ELEMENTS_HEIGHT = disc['elements_height']

    # Check mesh limits (Abaqus Learning Edition has 1000 node limit)
    total_nodes = (N_ELEMENTS_LENGTH + 1) * (N_ELEMENTS_WIDTH + 1) * (N_ELEMENTS_HEIGHT + 1)
    total_elements = N_ELEMENTS_LENGTH * N_ELEMENTS_WIDTH * N_ELEMENTS_HEIGHT
    
    print(f"MESH PRE-CHECK: {total_elements} elements, {total_nodes} nodes")
    if total_nodes > 1000:
        print(f"WARNING: Node count ({total_nodes}) exceeds Abaqus Learning Edition limit (1000 nodes)")

    # Create model and part
    model = mdb.Model(name=MODEL_NAME)
    sketch = model.ConstrainedSketch(name='beamProfile', sheetSize=1.0)
    sketch.rectangle(point1=(-PART_WIDTH/2, -PART_HEIGHT/2), point2=(PART_WIDTH/2, PART_HEIGHT/2))
    part = model.Part(name='Beam', dimensionality=THREE_D, type=DEFORMABLE_BODY)
    part.BaseSolidExtrude(sketch=sketch, depth=PART_LENGTH)

    # Define material and section
    material = model.Material(name=MAT_NAME)
    material.Elastic(table=((YOUNGS_MODULUS, POISSON_RATIO), ))
    section = model.HomogeneousSolidSection(name='BeamSection', material=MAT_NAME)
    part.SectionAssignment(region=(part.cells,), sectionName='BeamSection')

    # Create assembly
    assembly = model.rootAssembly
    instance = assembly.Instance(name='BeamInstance', part=part, dependent=ON)

    # Define step, boundary conditions, and loads
    step = model.StaticStep(name='Step-1', previous='Initial')
    
    fixed_face_geom = instance.faces.findAt(((0.0, 0.0, 0.0),))
    load_point_geom = instance.vertices.findAt(((PART_WIDTH/2, PART_HEIGHT/2, PART_LENGTH),))
    
    assembly.Set(faces=fixed_face_geom, name='Set-FixedEnd')
    fixed_region = model.rootAssembly.sets['Set-FixedEnd']
    assembly.Set(vertices=load_point_geom, name='Set-LoadPoint')
    load_region = model.rootAssembly.sets['Set-LoadPoint']
    
    model.EncastreBC(name='Fixed', createStepName='Initial', region=fixed_region)
    model.ConcentratedForce(name='TipLoad', createStepName='Step-1', 
                            region=load_region, cf3=-TIP_LOAD)

    # Mesh generation
    part.setMeshControls(regions=part.cells, elemShape=HEX, technique=STRUCTURED)

    # Find edges for seeding
    W, H, L = PART_WIDTH, PART_HEIGHT, PART_LENGTH
    W2, H2, L2 = W/2.0, H/2.0, L/2.0

    length_edges = (
        part.edges.findAt(coordinates=(W2, H2, L2)),
        part.edges.findAt(coordinates=(-W2, H2, L2)),
        part.edges.findAt(coordinates=(-W2, -H2, L2)),
        part.edges.findAt(coordinates=(W2, -H2, L2))
    )

    width_edges = (
        part.edges.findAt(coordinates=(0, H2, 0)),
        part.edges.findAt(coordinates=(0, -H2, 0)),
        part.edges.findAt(coordinates=(0, H2, L)),
        part.edges.findAt(coordinates=(0, -H2, L))
    )

    height_edges = (
        part.edges.findAt(coordinates=(W2, 0, 0)),
        part.edges.findAt(coordinates=(-W2, 0, 0)),
        part.edges.findAt(coordinates=(W2, 0, L)),
        part.edges.findAt(coordinates=(-W2, 0, L))
    )

    # Apply seeds and generate mesh
    part.seedEdgeByNumber(edges=length_edges, number=N_ELEMENTS_LENGTH, constraint=FIXED)
    part.seedEdgeByNumber(edges=width_edges, number=N_ELEMENTS_WIDTH, constraint=FIXED)
    part.seedEdgeByNumber(edges=height_edges, number=N_ELEMENTS_HEIGHT, constraint=FIXED)
    part.generateMesh()
    
    # Submit job and extract results
    job = mdb.Job(name=MODEL_NAME, model=MODEL_NAME, type=ANALYSIS)
    job.submit(consistencyChecking=OFF)
    job.waitForCompletion()
    extract_results(MODEL_NAME)

def extract_results(model_name: str) -> None:
    """
    Extract maximum displacement from simulation results and save to results.json.
    
    Args:
        model_name: Name of the Abaqus model/job
    """
    from odbAccess import openOdb
    
    odb_path = model_name + '.odb'
    odb = openOdb(path=odb_path)
    
    # Extract max displacement from last frame
    last_step = odb.steps.values()[-1]
    last_frame = last_step.frames[-1]
    displacement_field = last_frame.fieldOutputs['U']
    
    max_disp = 0.0
    for value in displacement_field.values:
        if value.magnitude > max_disp:
            max_disp = value.magnitude
    
    odb.close()
    
    # Write results for worker to read
    results = {
        "max_displacement": max_disp,
        "units": "m"
    }
    with open('results.json', 'w') as f:
        json.dump(results, f)


if __name__ == '__main__':
    CONFIG_FILE = 'config.json'
    
    try:
        with open(CONFIG_FILE, 'r') as f:
            config = json.load(f)
    except IOError:
        raise FileNotFoundError(f"{CONFIG_FILE} not found in current directory")
    
    test_type = config.get('TEST_TYPE')
    
    if test_type == 'CantileverBeam':
        run_cantilever_beam(config)
    elif test_type == 'TaylorImpact':
        raise NotImplementedError("TaylorImpact workflow not yet implemented")
    else:
        raise ValueError(f"Unknown TEST_TYPE: '{test_type}' in config.json")


